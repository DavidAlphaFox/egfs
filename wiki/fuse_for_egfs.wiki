#summary 使用fuse挂载egfs
#labels Phase-Design


= Introduction =

   <p>
我们的分布式存储系统－－egfs已经初步可用，但是如何方便地应用它，同时对它进行实际测试?<br/>我们采用的方案是：
     * 用fuse把egfs挂载到本地;
     * 然后在上面架上我们的corsair系统;
     * 借助于corsair的大量用户进行测试，同时推广egfs的应用。<br/>

而[http://code.google.com/p/fuserl/ fuserl]已经实现了fuse的erlang driver, 我们就在fuserl的基础上，编写fuse相应的erlang回调函数，<br/>就可以实现将egfs挂载到本地. 本文档主要描述如何用egfs提供的接口实现这些回调函数。
   </p>


= Implementation Details =
<p>
模块fusefs实现了所需的回调函数，回调函数统一在efs.erl文件中定义；在efs中，有一个重要的全局变量*State#egfsrv*,它有三个成员：
    * a. inode: type＝gb_trees, 动态存储(inode, Path)值对；
    * b. names: type = gb_trees, 动态存储(Path, inode)值对, 与inodes的内容一一对应；
    * c. pids: type = ets, 动态存储(FileHandle, WorkerPid)值对。<br/>
下面对efs中实现的回调函数的原型、所要完成的功能、返回值及实现细节进行说明。
</p>

  ==== getattr/4, 根据文件的inode获得文件的attributes ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   getattr (Ctx::#fuse_ctx{}, Inode::integer (), Cont::continuation (), State) ->
         { getattr_async_reply (), NewState } | { noreply, NewState } 
   getattr_async_reply () = #fuse_reply_attr{} | #fuse_reply_err{}
     }}}
   @doc
     Get the file attributes associated with an inode.  If noreply is used,
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont
     as first argument and the second argument of type getattr_async_reply ().
   @end
   * 实现细节
    只使用到了Inode和State两个参数；<br/>
    根据Inode, 查询State#inodes, 得到Path;<br/>
    根据Path, 调用egfs:read_file_info得到文件的相应属性，并转换为fuse所需的格式；<br/>
    正常返回值是{ #fuse_reply_attr{}, NewState};<br/>
    异常返回值是{ #fuse_reply_err{], State}.<br/>
   </div>
</p>

  ==== setattr/7, 设置与inode对应的文件的属性 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   setattr (Ctx::#fuse_ctx{}, Inode::integer (), Attr::#stat{}, ToSet::integer (),
            Fi::maybe_fuse_file_info (), Cont::continuation (), State) ->
        { setattr_async_reply (), NewState } | { noreply, NewState }
   maybe_fuse_file_info () = #fuse_file_info{} | null
   setattr_async_reply () = #fuse_reply_attr{} | #fuse_reply_err{}
     }}}
   @doc
     Set file attributes.ToSet is a bitmask which defines which
     elements of Attr are defined and should be modified.  Possible values
     are defined as ?FUSE_SET_ATTR_XXXX in fuserl.hrl . Fi will be set
     if setattr is invoked from ftruncate under Linux 2.6.15 or later.
     If noreply is used,
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type setattr_async_reply ().
   @end
   * 实现细节
    该函数并未真正实现
   </div>
</p>

  ==== lookup/5, 查找目录(inode)下某个文件(BName)的属性 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   lookup (Ctx::#fuse_ctx{}, ParentInode::integer (), Name::binary (), Cont::continuation (), State) -> 
	   { lookup_async_reply (), NewState } | { noreply, NewState }
   lookup_async_reply () = #fuse_repoply_entry{} | #fuse_reply_err{}
     }}}
   @doc
     Lookup a directory entry by name and get its attributes.  Returning
     an entry with inode zero means a negative entry which is cacheable, whereas
     an error of enoent is a negative entry which is not cacheable.
     If noreply is used, 
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type lookup_async_reply ().
   @end
   * 实现细节
    根据目录的inode查找该文件夹的Path;<br/>
    根据Path调用egfs:listdir得到该目录的全部子文件/夹；<br/>
    如果名字为Name的子文件/夹存在，就调用egfs:read_file_info, 得到属性,并返回给fuse;<br/>
    如果不存在，则返回{#fuse_reply_err{err=enoent}, State}.<br/>
   </div>
</p>

  ==== create/7, 创建一个文件，并将之打开 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   create (Ctx::#fuse_ctx{}, Parent::integer (), Name::binary (), Mode::create_mode (), 
	       Fi::#fuse_file_info{}, Cont::continuation (), State) -> 
        { create_async_reply (), NewState } | { noreply, NewState } 
   create_async_reply () = #fuse_reply_create{} | #fuse_reply_err{}
     }}}
   @doc
     Create and open a file.
     Mode is a bitmask consisting of ?S_XXXXX macros portably defined in fuserl.hrl .
     If noreply is used, 
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type create_async_reply ().
   @end
   * 实现细节
    根据Parent(Inode)得到父目录的全路径，然后与Name组合，得到待建文件的全路径Path;<br/>
    调用egfs:open以write方式打开Path, 然后立即关闭，完成文件的创建；<br/>
    调用egfs:open以append方式再次打开Path, 把得到的{Handle, WorkerPid}存入egfsrv.pids;<br/>
    把文件的handle以及属性返回给fuse.<br/>
   </div>
</p>

  ==== unlink/5, 删除目录(Inode)下的一个文件(Name) ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   unlink (Ctx::#fuse_ctx{}, Inode::integer (), Name::binary (), Cont::continuation (), State) -> 
        { unlink_async_reply (), NewState } | { noreply, NewState }
   unlink_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     Remove a file.  #fuse_reply_err{err = ok} indicates success.
     If noreply is used, 
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type unlink_async_reply ().
   @end
   * 实现细节
    根据Inode获得父目录的全路径, 然后与Name组合得到待删文件的全路径Path；<br/>
    调用egfs:delete, 删除Path;<br/>
    清除Path在全局变量中的信息(egfsrv.inode, egfsrv.names);<br/>
    返回{#fuse_reply_err{err = ok}, NewState}.<br/>
   </div>
</p>

  ==== open/5, 以Fi中指定的mode打开Inode对应的文件 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   unlink (Ctx::#fuse_ctx{}, Inode::integer (), Name::binary (), Cont::continuation (), State) -> 
        { unlink_async_reply (), NewState } | { noreply, NewState }
   unlink_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     Open an inode. If noreply is used, eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} 
     should be called with Cont as first argument and the second argument of type
     open_async_reply ().
   @end
   * 实现细节
    根据Inode获得待打开文件的全路径Path；<br/>
    调用egfs:open，打开文件Path, 获得相应的(Handle, WorkerPid);<br/>
    将(Handle, WorkerPid)值对存入egfsrv.pids；再将Handle及其他信息返回给fuse.<br/>
   </div>
</p>

  ==== release/5, 关闭Inode对应的文件 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   release(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -> 
		{ release_async_reply (), NewState } | { noreply, NewState } 
   release_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     Called when there are no more references to a file.
     For every {@link open/4. open} call there is exactly one release call.
     Fi#fuse_file_info.fh will contain the descriptor set in {@link open/4. open}, if any.  
     Fi#fuse_file_info.flags will contain the same flags as for {@link open/4. open}.
     #fuse_reply_err{err = ok} indicates success.
     Errors are not reported anywhere; use {@link flush/4. flush} for that.
     If noreply is used, 
      eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
      and the second argument of type release_async_reply ().
   @end
   * 实现细节
    只使用到了Fi参数，根据Fi.fh, 查找egfsrv.pids，得到相应的WorkerPid;<br/>
       调用egfs.close(WorkerPid);<br/>
       删除egfsrv.pids中相应的信息.<br/>
   </div>
</p>

  ==== read/7, 在Fi.fh对应的文件中，读取从Offset开始Size个字节的内容. ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   read (Ctx::#fuse_ctx{}, Inode::integer (), Size::integer (), Offset::integer (), 
	     Fi::#fuse_file_info{}, Cont::continuation (), State) -> 
       { read_async_reply (), NewState } | { noreply, NewState }
   read_async_reply () = #fuse_reply_buf{} | #fuse_reply_err{}
     }}}
   @doc
     Read Size bytes starting at offset Offset. The file descriptor and other flags are available in Fi. 
     If noreply is used, 
       eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
       and the second argument of type read_async_reply ().
   @end
   * 实现细节
    只用到Size, Offset, Fi和State参数；<br/>
    根据Fi.fh查找egfsrv.pids得到相应的WorkerPid;<br/>
    根据WorkerPid调用egfs:pread，读取相应的内容.<br/>
   </div>
</p>

  ==== write/7, 将Data写入Fi.fh中指定的位置 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   write(Ctx::#fuse_ctx{}, Inode::integer (), Data::binary (), Offset::integer (), 
	     Fi::#fuse_file_info{}, Cont::continuation (), State) -> 
       { write_async_reply (), NewState } | { noreply, NewState }
   write_async_reply () = #fuse_reply_write{} | #fuse_reply_err{}
     }}}
   @doc
     Write data to a file. If noreply is used, 
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type write_async_reply ().
   @end
   * 实现细节
    只用到Data, Offset, Fi和State参数;<br/>
    根据Fi.fh查找egfsrv.pids得到相应的WorkerPid;<br/>
    根据WorkerPid调用egfs:write，将Data写入.<br/>
   </div>
</p>

  ==== flush/5, 将缓冲区内容写入文件 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   flush(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -> 
       { flush_async_reply (), NewState } | { noreply, NewState } 
   flush_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     This is called on each close () of an opened file, possibly multiple times per open/4 call
     (due to dup() et. al.).  
     Fi#fuse_file_info.fh will contain the descriptor set in open/4, if any.  
     #fuse_reply_err{err = ok} indicates success.
     This return value is ultimately the return value of close () (unlike release/4).
     Does *not* necessarily imply an fsync.
     If noreply is used, 
      eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
      and the second argument of type flush_async_reply ().
   @end
   * 实现细节
    该函数并未真正实现.<br/>
   </div>
</p>

  ==== rename/7，将Parent下的文件/夹Name移到NewParent下,名字改为NewName ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   rename (Ctx::#fuse_ctx{}, Parent::integer (), Name::binary (), NewParent::integer (), 
	       NewName::binary (), Cont::continuation (), State) -> 
       { rename_async_reply (), NewState } | { noreply, NewState }
   rename_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     Rename a file.  #fuse_reply_err{err = ok} indicates success.
     If noreply is used, 
      eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
      and the second argument of type rename_async_reply ().
   @end
   * 实现细节
    根据Parent及Name得到源文件的Path;<br/>
    根据NewParent及NewName得到目的文件的NewPath;<br/>
    调用egfs:move, 实现文件的重命名;<br/>
    清除egfsrv.inodes, egfsrv.names中对应Path的信息;<br/>
    添加egfsrv.inodes, egfsrv.names中NewPath的信息.<br/>
   </div>
</p>

  ==== mkdir/6, 在目录ParentInode下创建新目录(Name) ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   mkdir (Ctx::#fuse_ctx{}, ParentInode::integer (), Name::binary (), Mode::stat_mode (), 
	      Cont::continuation (), State) -> 
       { mkdir_async_reply (), NewState } | { noreply, NewState }
   mkdir_async_reply () = #fuse_reply_entry{} | #fuse_reply_err{}
     }}}
   @doc
     Make a directory.  Mode is a mask composed of the ?S_XXXXX macros
     which are (portably) defined in fuserl.hrl.
     If noreply is used, 
      eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
      and the second argument of type mkdir_async_reply ().
   @end
   * 实现细节
    根据ParentInode查到待建目录的父目录全路径，与Name组合，得到待建全路径Path;<br/>
    调用egfs:mkdir建立新目录;<br/>
    把新目录的(inode, Path)值对加入egfsrv.inodes和egfsrv.names;<br/>
    获取新目录的属性，返回给fuse.<br/>
   </div>
</p>

  ==== rmdir/5, 删除Inode下名字为Name的目录 ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   rmdir (Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Cont::continuation(), State) -> 
       { rmdir_async_reply (), NewState } | { noreply, NewState }
   rmdir_async_reply () = #fuse_reply_err{}
     }}}
   @doc
     Remove a directory.  #fuse_reply_err{err = ok} indicates success.
     If noreply is used, 
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont as first argument
     and the second argument of type rmdir_async_reply ().
   @end
   * 实现细节
    根据ParentInode查到待删目录的父目录全路径，与Name组合，得到待删全路径Path;<br/>
    调用egfs:deldir删除对应目录;<br/>
    把该目录的(inode, Path)信息从egfsrv.inodes和names中清除;<br/>
    返回{#fuse_reply_err{err = ok, NewState}给fuse;<br/>
    把新目录的(inode, Path)值对加入egfsrv.inodes和egfsrv.names.<br/>
   </div>
</p>

  ==== readdir/7, 获取目录Inode下所有文件的属性及其对应的inode ====
<p>
  <div>
   * 定义
   @spec
     {{{ 
   readdir (Ctx::#fuse_ctx{}, Inode::integer (), Size::integer (), Offset::integer (), 
	        Fi::#fuse_file_info{}, Cont::continuation (), State) -> 
        { readdir_async_reply (), NewState } | { noreply, NewState }
   readdir_async_reply () = #fuse_reply_direntrylist{} | #fuse_reply_err{}
     }}}
   @doc
     Get the file attributes associated with an inode.  If noreply is used,
     eventually {@link fuserlsrv:reply/2. fuserlsrv:reply/2} should be called with Cont
     as first argument and the second argument of type getattr_async_reply ().
   @end
   * 实现细节
    实现最复杂的一个函数<br/>
    首先获取"." ".."两个特殊子目录的属性 ＋ inode；<br/>
    然后获取其常规子文件(或文件夹)的属性 + inode;<br/>
    接着把两者合并起来，转换成fuse所需要的格式，返回给fuse.<br/>
   </div>
</p>

*备注*
@spec等英文部分是从fuserl.erl中摘录的，各函数中#fuse_*等数据结构在fuserl.hrl中定义.